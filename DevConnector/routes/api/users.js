const express = require("express");
const router = express.Router();
const gravatar = require("gravatar");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcryptjs");
const { check, validationResult } = require("express-validator/check");

//0. for some reason we have to /../ navigate back up the directory tree to get the User model
//   but this is not necessary for the config directory?
const config = require("config");
const Users = require("../../models/User");

// @route  POST api/users
// @desc   register user
// @access public

// 1. when the client calls router.post, the whole request is stored inside the req variable
//    e.g. req.body, req.headers, or something like that
//    it also stores the response data in res
//    e.g. res.body, res.headers, res.status
router.post(
  // 2. this is the path of the route the client sends to.
  //    in this case it is the directory structure in the project.
  "/",

  // 3. express library can make an array of assertions against the body content for validation before the call is made.
  //    not sure how to assert vs. headers and GET params, though
  [
    check("name", "Name is required")
      .not()
      .isEmpty(),
    check("email", "Please enter a valid email").isEmail(),
    check(
      "password",
      "please enter a password with 6 or more characters"
    ).isLength({ min: 6 })
  ],
  // 4. start the sequence, requires a callback.  must pass in req and res for each call.
  async (req, res) => {
    // 5. express method validationResult() takes the request and performs the checks
    //    not sure how validationResult() consumes the array of checks, though
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    // 6. set the name email password as constants from req.body
    //    not sure about how this syntax works... it just does it automagically - found out, it's called destructuring
    const { name, email, password } = req.body;

    // 7. Set up try-catch.  this is required for the async keyword
    try {
      // 8. use mongoose to see if the user exists in the database
      //    mongoose syntax Tablename.findOne({field value as an object}) returns boolean if exists in table
      //    callback based - async/await 'promisifies' callbacks
      let user = await Users.findOne({ email });

      // 9. return 400 as user exists.
      //    if the user does not exist, all the steps below the if-block should be in an else-block I think?
      if (user) {
        return res.status(400).json({ message: "User already exists" });
      }

      // 10. Get user's avatar using the gravatar library
      //     it can search it's db by email and return the avatar's url
      //     also, some config values are set, s: size, r: rating, d: default
      const avatar = gravatar.url(email, {
        s: 200,
        r: "pg",
        d: "mm"
      });

      // 11. takes the variables created from the request body from step 6 and creates a new User model
      //     this will be what is saved to mongodb
      user = new User({
        name,
        email,
        password,
        avatar
      });

      // 12. before saving, we must encrypt the password
      //     bcrypt library can generate a salted hash.
      //     promise based - requires await
      const salt = await bcrypt.genSalt(10);

      // 13. the password is hashed using the bcrypt library.
      //     the hashing function takes the string to be encrypted, and the salt (if necessary)
      //     we set the hash to overwrite the password variable.
      //     promise based - requires await
      user.password = await bcrypt.hash(password, salt);

      // 14. saves the updated user model to mongodb.
      //     promise based - requires await
      await user.save();

      // 15. creates the payload object variable, inorder to send to JWT to create a token
      //     consists of a user object with the id value autogenerated in mongodb
      //     mongoose is smart: .id is a virtual getter on the model variable we created above named "user"
      //     it returns the id, sets it in the payload, then the "payload" variable is populated with the object
      const payload = {
        user: {
          id: user.id
        }
      };

      // 16. Call the JWT library's .sign() method
      //     it takes the payload, a secret, some settings (expiry), and a callback
      //     the secret lives under the config directory, in the default.json file... not sure how .get() works here
      //     not sure why we're not using the await keyword here instead of the callback, though
      //     res.json({key}) will return the key:value in the response body
      jwt.sign(
        payload,
        config.get("jwtSecret"),
        {
          expiresIn: 360000
        },
        (err, token) => {
          if (err) throw err;
          res.json({ token });
        }
      );
    } catch (err) {
      // 17. if anything above breaks, catch the error and just return a 500 for the POST call
      //     and print out "Server error" in the response
      console.log(err);
      res.status(500).send("Server error");
    }
  }
);

// 18. export this so that it can be made global
//     module.exports is the nodejs keyword for making methods here global
//     not sure what router; represents though
module.exports = router;
